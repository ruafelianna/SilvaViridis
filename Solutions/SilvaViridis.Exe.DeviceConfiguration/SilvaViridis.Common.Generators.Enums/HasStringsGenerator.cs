using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using SilvaViridis.Common.Generators.Extensions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

namespace SilvaViridis.Common.Generators.Enums
{
    [Generator(LanguageNames.CSharp)]
    public class HasStringsGenerator : IIncrementalGenerator
    {
        public void Initialize(
            IncrementalGeneratorInitializationContext context
        )
        {
            context.RegisterPostInitializationOutput(GenerateAttribute);

            var source1 = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    $"{NS_Local}.{A_HasStringsFull}",
                    IsEnum,
                    TransformEnum
                )
                .Where(record => record is not null);

            var source2 = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    $"{NS_Local}.{A_HasStringsFull}`2",
                    IsEnum,
                    TransformEnum
                )
                .Where(record => record is not null);

            context.RegisterSourceOutput(source1, GenerateSourceCode);

            context.RegisterSourceOutput(source2, GenerateSourceCode);
        }

        private const string AttributeSourceCode = $@"{C_Autogenerated}

{DIR_NullableEnable}

{KW_Using} {PRE_Global}{NS_System};

{KW_Namespace} {NS_Local}
{{
    [{nameof(AttributeUsageAttribute)}({nameof(AttributeTargets)}.{nameof(AttributeTargets.Enum)})]
    {KW_Internal} {KW_Class} {A_HasStringsFull} : {nameof(Attribute)}
    {{
        {KW_Public} {KW_String}? {P_HasStrings_StringsNamespace} {{ {KW_Get}; {KW_Set}; }}

        {KW_Public} {KW_String}? {P_HasStrings_StringsClass} {{ {KW_Get}; {KW_Set}; }}

        {KW_Public} {KW_String}? {P_HasStrings_ExtNamespace} {{ {KW_Get}; {KW_Set}; }}

        {KW_Public} {KW_String}? {P_HasStrings_ExtClass} {{ {KW_Get}; {KW_Set}; }}

        {KW_Public} {KW_Bool} {P_HasStrings_GenerateFunctions} {{ {KW_Get}; {KW_Set}; }}
    }}

    {KW_Internal} {KW_Interface} {I_IFormatter}<{T_TObj}>
    {{
        {KW_String}? {M_AsString}({T_TObj}? {L_obj});
    }}

    [{nameof(AttributeUsageAttribute)}({nameof(AttributeTargets)}.{nameof(AttributeTargets.Enum)})]
    {KW_Internal} {KW_Class} {A_HasStringsFull}<{T_TObj}, {T_TFormatter}> : {A_HasStringsFull}
        {KW_Where} {T_TFormatter} : {KW_Class}, {I_IFormatter}<{T_TObj}>, {KW_New}()
    {{
        {KW_Public} {A_HasStringsFull}()
        {{
            {KW_Var} {L_fmt} = {KW_New} {T_TFormatter}();
            {M_AsString} = {L_fmt}.{M_AsString};
        }}

        {KW_Public} {nameof(Func<string>)}<{T_TObj}?, {KW_String}?> {M_AsString} {{ {KW_Get}; }}
    }}
}}

{DIR_NullableDisable}
";

        private record EnumInfo(
            string EnumName,
            string EnumNamespace,
            string[] EnumItems,
            string ClassName,
            string ClassNamespace,
            string ExtName,
            string ExtNamespace,
            bool GenerateFunctions,
            FmtInfo? FmtInfo
        );

        private record FmtInfo(
            string FmtName,
            string FmtNamespace,
            string FmtObjName,
            string FmtObjNamespace,
            string FmtTypeName,
            string FmtTypeNamespace
        );

        private static bool IsEnum(
            SyntaxNode node,
            CancellationToken token
        ) => node is EnumDeclarationSyntax;

        private static EnumInfo? TransformEnum(
            GeneratorAttributeSyntaxContext ctx,
            CancellationToken token
        )
        {
            #region Get enum info

            var enumSymbol = ctx.TargetSymbol;

            if (enumSymbol is not ITypeSymbol enumType)
            {
                return null;
            }

            var enumItems = enumType
                .GetMembers()
                .Where(x => !x.IsImplicitlyDeclared)
                .Select(x => x.Name)
                .ToArray();

            var enumName = enumSymbol.Name;

            var enumNamespace = enumSymbol.FullNS();

            #endregion

            #region Get attribute info

            var attr = ctx.Attributes[0];

            var clsName = attr.GetNamedValue<string>(
                P_HasStrings_StringsClass
            );

            if (!clsName.HasValue)
            {
                return null;
            }

            var clsNamespace = attr.GetNamedValue<string>(
                P_HasStrings_StringsNamespace
            );

            var extName = attr.GetNamedValue<string>(
                P_HasStrings_ExtClass
            );

            var extNamespace = attr.GetNamedValue<string>(
                P_HasStrings_ExtNamespace
            );

            var genFuncs = attr.GetNamedValue<bool>(
                P_HasStrings_GenerateFunctions
            );//false

            #endregion

            #region Get generic info

            var attrClass = attr.AttributeClass!;

            ITypeSymbol[]? genParams = [.. attrClass.TypeArguments];

            var hasFormatter = attrClass
                .GetMembers(M_AsString)
                .Any()
                && genParams.Length == 2;

            var fmtInfo = hasFormatter
                ? new FmtInfo(
                    attrClass.Name,
                    attrClass.FullNS(),
                    genParams[0].Name,
                    genParams[0].FullNS(),
                    genParams[1].Name,
                    genParams[1].FullNS()
                )
                : null;

            #endregion

            return new(
                enumName,
                enumNamespace,
                enumItems,
                clsName.Value,
                clsNamespace.HasValue
                    ? clsNamespace.Value
                    : enumNamespace,
                extName.HasValue
                    ? extName.Value
                    : $"{enumName}{POST_Extensions}",
                extNamespace.HasValue
                    ? extNamespace.Value
                    : enumNamespace,
                genFuncs.HasValue && genFuncs.Value,
                fmtInfo
            );
        }

        private static void GenerateAttribute(
            IncrementalGeneratorPostInitializationContext ctx
        ) => ctx.AddSource(
            $"{NS_Local}.{A_HasStringsFull}{EXT_GeneratedCSharp}",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)
        );

        private static void GenerateSourceCode(
            SourceProductionContext ctx,
            EnumInfo? enumInfo
        ) => ctx.AddSource(
            $"{enumInfo!.EnumNamespace}.{enumInfo.EnumName}{EXT_GeneratedCSharp}",
            GenerateClass(enumInfo)
        );

        private static string GenerateClass(EnumInfo enumInfo)
        {
            var fmtInfo = enumInfo.FmtInfo;

            var hasFormatter = fmtInfo is not null;

            var funcStart = hasFormatter
                ? $"() => {F_hasAttr}.{M_AsString}("
                : enumInfo.GenerateFunctions ? "() => " : null;

            var funcEnd = hasFormatter ? ")" : null;

            var dictType = enumInfo.GenerateFunctions
                ? $"{nameof(Func<int>)}<{KW_String}>"
                : KW_String;

            var funcBrackets = enumInfo.GenerateFunctions ? "()" : null;

            string? fmt = null;
            string? afterFmt = null;

            if (hasFormatter)
            {
                var fmtType = $"{fmtInfo!.FmtName}<{fmtInfo.FmtObjName}, {fmtInfo.FmtTypeName}>";

                fmt = $@"{KW_Private} {KW_Static} {KW_Readonly} {fmtType} {F_hasAttr}
{Tab}{Tab}{Tab}= ({fmtType}){nameof(Attribute)}.{nameof(Attribute.GetCustomAttribute)}(
{Tab}{Tab}{Tab}{Tab}{KW_TypeOf}({enumInfo.EnumName}),
{Tab}{Tab}{Tab}{Tab}{KW_TypeOf}({fmtType})
{Tab}{Tab}{Tab});";

                afterFmt = $"{NewLine}{NewLine}{Tab}{Tab}";
            }

            var items = enumInfo.EnumItems
                .Select(x =>
                    $"{Tab}{Tab}{Tab}{Tab}[{enumInfo.EnumName}.{x}] = {funcStart}{enumInfo.ClassName}.{x}{funcEnd},"
                );

            var ns = new string?[] {
                NS_System,
                NS_System_Collections_Generic,
                NS_Local,
                enumInfo.ClassNamespace,
                enumInfo.EnumNamespace,
                fmtInfo?.FmtNamespace,
                fmtInfo?.FmtObjNamespace,
                fmtInfo?.FmtTypeNamespace,
            }
                .Where(x => x is not null)
                .Distinct()
                .OrderBy(x => x)
                .Select(x => $"{KW_Using} {PRE_Global}{x};");

            return $@"{C_Autogenerated}

{string.Join(NewLine, ns)}

{KW_Namespace} {enumInfo.ExtNamespace}
{{
    {KW_Public} {KW_Static} {KW_Partial} {KW_Class} {enumInfo.ExtName}
    {{
        {KW_Public} {KW_Static} {KW_String} {M_AsString}(
            {KW_This} {enumInfo.EnumName} value
        ) => _{enumInfo.EnumName}{POST_Dict}[value]{funcBrackets};

        {fmt}{afterFmt}{KW_Private} {KW_Static} {KW_Readonly} {nameof(Dictionary<int, int>)}<{enumInfo.EnumName}, {dictType}> _{enumInfo.EnumName}{POST_Dict}
            = {KW_New}()
            {{
{string.Join(NewLine, items)}
            }};
    }}
}}
";
        }
    }
}
