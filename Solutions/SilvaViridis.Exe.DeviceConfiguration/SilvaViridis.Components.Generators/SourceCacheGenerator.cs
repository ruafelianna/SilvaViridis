using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using SilvaViridis.Common.CSharp.Enums;
using SilvaViridis.Common.Generators.Extensions;
using SilvaViridis.CSharp.Extensions;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading;

namespace SilvaViridis.Components.Generators
{
    [Generator(LanguageNames.CSharp)]
    public class SourceCacheGenerator : IIncrementalGenerator
    {
        public void Initialize(
            IncrementalGeneratorInitializationContext context
        )
        {
            context.RegisterPostInitializationOutput(GenerateAttribute);

            var source = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    $"{NS_Local}.{A_SourceCacheFull}",
                    IsField,
                    TransformField
                )
                .Where(value => value is not null)
                .Collect();

            context.RegisterSourceOutput(source, (ctx, collection)
                => {
                    var grouped = collection
                        .GroupBy(info => new
                        {
                            info!.ContainerKind,
                            info!.ContainerNamespace,
                            info!.ContainerName,
                        });

                    foreach (var group in grouped)
                    {
                        var array = group.ToImmutableArray();

                        if (array.Length > 0)
                        {
                            ctx.AddSource(
                                $"{group.Key.ContainerNamespace}.{group.Key.ContainerName}{EXT_GeneratedCSharp}",
                                GenerateSource(array!)
                            );
                        }
                    }
                }
            );
        }

        private const string AttributeSourceCode = $@"{C_Autogenerated}

{KW_Using} {PRE_Global}{NS_AccessModifier};
{KW_Using} {PRE_Global}{NS_System};

{KW_Namespace} {NS_Local}
{{
    [{nameof(AttributeUsageAttribute)}({nameof(AttributeTargets)}.{nameof(AttributeTargets.Field)})]
    {KW_Internal} {KW_Class} {A_SourceCacheFull} : {nameof(Attribute)}
    {{
        {KW_Public} {KW_String} {P_SourceCache_KeyTypeName} {{ {KW_Get}; {KW_Set}; }}

        {KW_Public} {KW_String} {P_SourceCache_KeyTypeNamespace} {{ {KW_Get}; {KW_Set}; }}

        {KW_Public} {E_AccessModifier} {P_SourceCache_CacheModifier} {{ {KW_Get}; {KW_Set}; }}

        {KW_Public} {E_AccessModifier} {P_SourceCache_PropertyModifier} {{ {KW_Get}; {KW_Set}; }}
    }}
}}
";

        private record OutputInfo(
            string ContainerKind,
            string ContainerName,
            string ContainerNamespace,
            string FieldName,
            string CacheName,
            AccessModifier CacheModifier,
            string PropertyName,
            AccessModifier PropertyModifier,
            string TypeArgName,
            string TypeArgNamespace,
            string KeyTypeName,
            string KeyTypeNamespace
        );

        private static bool IsField(
            SyntaxNode node,
            CancellationToken token
        ) => node is VariableDeclaratorSyntax;

        private OutputInfo? TransformField(
            GeneratorAttributeSyntaxContext ctx,
            CancellationToken token
        )
        {
            if (ctx.TargetSymbol is not IFieldSymbol fieldSymbol)
            {
                return null;
            }

            #region Check field type

            var fieldTypeName = fieldSymbol.Type.Name;

            var fieldTypeNamespace = fieldSymbol.Type.FullNS();

            if (
                fieldTypeName != nameof(ReadOnlyObservableCollection<int>)
                || fieldTypeNamespace != NS_System_Collections_ObjectModel)
            {
                return null;
            }

            #endregion

            #region Get container info

            var objectKind = fieldSymbol.ContainingType.TypeKind switch
            {
                TypeKind.Class => KW_Class,
                TypeKind.Struct => KW_Struct,
                _ => null,
            };

            if (objectKind is null)
            {
                return null;
            }

            var objectName = fieldSymbol.ContainingType.Name;

            var objectNamespace = fieldSymbol.FullNS();

            #endregion

            #region Get field and property names

            var fieldName = fieldSymbol.Name;

            var trimmedFieldName = fieldName.TrimStart('_');

            var cacheName = $"{fieldName}{POST_Cache}";

            var propertyName = $"{trimmedFieldName[..1].ToUpper()}{trimmedFieldName[1..]}";

            #endregion

            #region Get type arguments

            if (
                fieldSymbol.Type is not INamedTypeSymbol nType
                || !nType.IsGenericType
                || nType.TypeArguments.Length != 1
            )
            {
                return null;
            }

            var firstArg = nType.TypeArguments[0];

            var typeArgName = firstArg.Name;

            var typeArgNamespace = firstArg.FullNS();

            var attr = ctx.Attributes[0];

            var keyTypeName = attr.GetNamedValue<string>(
                P_SourceCache_KeyTypeName
            );

            if (!keyTypeName.HasValue)
            {
                return null;
            }

            var keyTypeNamespace = attr.GetNamedValue<string>(
                P_SourceCache_KeyTypeNamespace
            );

            var cacheModifier = attr.GetNamedValue<AccessModifier>(
                P_SourceCache_CacheModifier
            );

            var propertyModifier = attr.GetNamedValue<AccessModifier>(
                P_SourceCache_PropertyModifier
            );

            #endregion

            return new(
                objectKind,
                objectName,
                objectNamespace,
                fieldName,
                cacheName,
                cacheModifier.HasValue
                    ? cacheModifier.Value
                    : AccessModifier.Private,
                propertyName,
                propertyModifier.HasValue
                    ? propertyModifier.Value
                    : AccessModifier.Public,
                typeArgName,
                typeArgNamespace,
                keyTypeName.Value,
                keyTypeNamespace.HasValue
                    ? keyTypeNamespace.Value
                    : NS_System
            );
        }

        private static void GenerateAttribute(
            IncrementalGeneratorPostInitializationContext ctx
        ) => ctx.AddSource(
            $"{NS_Local}.{A_SourceCacheFull}{EXT_GeneratedCSharp}",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)
        );

        private static string GenerateSource(
            ImmutableArray<OutputInfo> source
        )
        {
            var containerInfo = source[0];

            var nsList = new List<string>(source.Length + 2)
            {
                NS_DynamicData,
                NS_System_Collections_Generic,
            };

            var cache = new List<string>(source.Length);

            var prop = new List<string>(source.Length);

            foreach (var item in source)
            {
                nsList.Add(item.TypeArgNamespace);
                nsList.Add(item.KeyTypeNamespace);

                cache.Add(
                    $"{Tab}{Tab}{item.CacheModifier.AsString()} {KW_Readonly} {CL_SourceCache}<{item.TypeArgName}, {item.KeyTypeName}> {item.CacheName};"
                );

                prop.Add(
                    $"{Tab}{Tab}{item.PropertyModifier.AsString()} {nameof(IEnumerable<int>)}<{item.TypeArgName}> {item.PropertyName} => {item.FieldName};"
                );
            }

            var ns =  nsList
                .Distinct()
                .OrderBy(n => n)
                .Select(n => $"{KW_Using} {PRE_Global}{n};");

            return $@"{C_Autogenerated}

{string.Join(NewLine, ns)}

{KW_Namespace} {containerInfo.ContainerNamespace}
{{
    {KW_Partial} {containerInfo.ContainerKind} {containerInfo.ContainerName}
    {{
{string.Join(NewLine, cache)}

{string.Join(NewLine, prop)}
    }}
}}
";
        }
    }
}
